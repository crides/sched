let { to_list, singleton, find, insert, ? } = import! std.map
let array @ { Array, ? } = import! std.array
let list @ { List, ? } = import! std.list
let { println, eprintln, ? } = import! std.io
let string = import! std.string
let { proc, execute } = import! std.process
let { Result, unwrap_ok, to_option, ? } = import! std.result
let sched = import! sched
let { log = { Log, ? }, map = { Map, ? }, obj = { Object, ? }, json = { Value, ? }, ? } = import! util
let { datetime, duration, ? } = import! time
let { DateTime, ? } = datetime
let { Duration, ? } = duration
let { (<|), (|>) } = import! std.function
let { (<>) } = import! std.semigroup
let { (>>=) } = import! std.monad
let { empty } = import! std.monoid
let { map } = import! std.functor
let { cmd, value_of, values_of } = import! cmd
let { unwrap, unwrap_or } = import! std.option
let { Foldable, any, all, foldl, foldr } = import! std.foldable
let { for } = import! std.traversable
let { ? } = import! std.char
let { (<*), (*>), wrap } = import! std.applicative
let { to_string, ? } = import! std.json.ser

// Pure utility functions
let arr_to_map a : Array String -> Map String Value =
    (foldl (\mk x ->
            let { m, k } = mk
            match k with
            | Some key -> { m = insert key (String x) m, k = None }
            | None -> { m, k = Some x })
        { m = empty, k = None } a).m

let notify body : String -> IO () =
    seq execute (proc "notify-send" ["Sched", body])
    wrap ()

let naughty m: Map String Value -> IO () =
    let m = map (\kv ->
        let { key, value } = kv
        let v = show value
        key <> "=" <> v) (to_list m)
    seq proc "awesome-client" ["naughty.notify({" <> (join "," m) <> "})"] |> execute
    wrap ()

seq cmd "log"
    "<type>     'Type for the log'
     -d --desc=[desc]   	  'Optional description. Equivalent to -a desc ...'
     -a --attr [key] [val]... 'Optional attributes'"
    (\m ->
        let typ = unwrap (value_of m "type")
        let attrs = arr_to_map (values_of m "attr")
        let attrs =
            match value_of m "desc" with
            | Some d -> insert "desc" (String d) attrs
            | None -> attrs
        let log = unwrap_ok (sched.log.new typ attrs)
        seq println (show log.id)
        wrap ())

cmd "list"
    "<type>     'Object/Logs to list'
     [limit]    'Number of objects/logs to list. Default 10'"
    (\m ->
        let s =
            match unwrap <| value_of m "type" with 
            | "log" -> show <| sched.log.find (\l -> True) (Some 10)
            | "obj" -> show <| sched.obj.find (\o -> True) (Some 10)
            | _ -> "else"
        println s)
